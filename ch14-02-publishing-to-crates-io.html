<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bir Sandığı Crates.io Üzerinde Yayınlamak - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="title-page.html">Rust Programlama Dili</a></li><li class="affix"><a href="foreword.html">Önsöz</a></li><li class="affix"><a href="ch00-00-introduction.html">Giriş</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Kurulum</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Bir Tahmin Oyunu Programlamak</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Ortak Programlama Kavramları</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişkenlik</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> İşlevler</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorumlar</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Mülkiyeti Anlamak</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Mülkiyet Nedir?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Borçlanma</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlişkili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklemek</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Sözdizimi</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Sıralamalar ve Örüntü Eşleme</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Bir Sıralama Tanımlamak</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Kontrol Akışı İşleci match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akışı</a></li></ol></li><li><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Sandıklar ve Modüller ile Yönetmek</a></li><li><ol class="section"><li><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Sandıklar</a></li><li><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Kapsam ve Gizlilik Kontrolü İçin Modül Tanımlamak</a></li><li><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki Bir Öğeye Başvurmanın Yolları</a></li><li><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Anahtar Kelimesi ile Yolları Kapsama Getirmek</a></li><li><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Ortak Koleksiyonlar</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Değer Listelerini Vektör Kullanarak Depolamak</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Dizgelerle UTF-8 Kodlu Metinleri Saklamak</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlere Sahip Anahtarları Eşleme Haritalarında Saklamak</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamaz Hatalar</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! Olmak ya da panic! Olmamak</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Genellenmiş Türler, Özellikler ve Yaşam Süreleri</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Genellenmiş Veri Türleri</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Özellikler: Paylaşılan Davranışı Tanımlamak</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referansları Yaşam Süreleri ile  Doğrulamak</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatik Testler Yazmak</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır?</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştırılacağını Denetlemek</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir I/O Projesi: Komut Satırı Programı Oluşturmak</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Kabul Etmek</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Bir Dosyayı Okumak</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerlik ve Hata Yönetimini Geliştirmek İçin Yeniden Düzenlemek</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphane İşlevselliğini Artırmak</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenleriyle Çalışmak</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı Yerine Standart Hataya Yazmak</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> İşlevsel Dil Özellikleri: Yineleyiciler ve Kapamalar</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapamalar: Ortam Değişkenlerini Yakalayabilen İsimsiz İşlevler</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyiciler ile Bir Dizi Öğeyi İşlemek</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O Projemizi Geliştirmek</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Karşılaştırması: Döngüler vs. Yineleyiciler</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Sürüm Profilleriyle Derlemeleri Özelleştirmek</a></li><li><a href="ch14-02-publishing-to-crates-io.html" class="active"><strong aria-hidden="true">14.2.</strong> Bir Sandığı Crates.io Üzerinde Yayınlamak</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Crates.io Üzerindeki İkili Sandıkları cargo install Komutuyla Yüklemek</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo Olanaklarını Genişletmek</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Heap Üzerindeki Verilere İşaret Etmek İçin Box<T> Kullanmak</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Özelliği ile Akıllı İşaretçilere Normal Referanslar Gibi Davranmak</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Özelliği ile Kodu Temizlik Amaçlı Çalıştırmak</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, Referans Sayılı Akıllı İşaretçi</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> ve İç Değişkenlik Modeli</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Çevrimleri Bellek Sızıntısına Yol Açabilir</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Eşzamanlı Kod Çalıştırmak İçin İşlikleri Kullanmak</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> İşlikler Arasında Veri Aktarmak Amacıyla Mesajlaşma</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Durum Paylaşımlı Eşzamanlılık</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync and Send Özellikleri ile Genişletilebilir Eşzamanlılık</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'ın Nesne Yönelimli Programlama Özellikleri</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Özellikleri</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türden Değerlere İzin Veren Özellik Nesnelerini Kullanmak</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesne Yönelimli Tasarım Kalıbı Uygulamak</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Örüntü ve Eşleme</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Örüntüler Her Yerde Kullanılabilir</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Çürütülebilirlik: Bir Örüntünün Eşleşmeme İhtimali</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Örüntü Sözdizimi</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Emniyetsiz Rust</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Özellikler</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelişmiş İşlev ve Kapamalar</a></li><li><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çok İşlikli Web Sunucusu Oluşturmak</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İşlikli Bir Web Sunucusu Oluşturmak</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İşlikli Sunucumuzu Çok İşlikli Bir Sunucuya Dönüştürmek</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Sorunsuzca Kapatmak ve Temizlik</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ekler</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Kelimeler</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - İşleçler ve Semboller</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Özellikler</a></li><li><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Faydalı Geliştirme Araçları</a></li><li><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitabın Çevirileri</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust Nasıl “Nightly Rust” Yapılır? </a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#bir-sandığı-cratesio-Üzerinde-yayınlamak" id="bir-sandığı-cratesio-Üzerinde-yayınlamak"><h2>Bir Sandığı Crates.io Üzerinde Yayınlamak</h2></a>
<p>Önceki bölümlerde gerçekleştirdiğimiz bazı örnek projeler, çalışabilmek için <a href="https://crates.io/">crates.io</a>'daki bazı paketlere bağımlı olduklarından, bu paketleri projelerimize dahil etmeyi öğrenmiştik. Halbuki sizler de kendi paketlerinizi yayınlayarak kodlarınızı başkalarıyla paylaşabilirsiniz. <a href="https://crates.io/">Crates.io</a> sitesinde bulunan sandık kayıt defteri, paketlerinizin kaynak kodunu dağıtacağından, öncelikle projenizin açık kaynak kodunu barındırmak zorundadır.</p>
<p>Rust ve Cargo, yayınlanan paketleri başka geliştiricilerin kolaylıkla bulup kullanabilmelerini sağlayan özelliklere sahiptir. Az sonra bu özelliklerin bazılarından bahsedecek ve ardından bir paketin nasıl yayınlanacağını anlatacağız.</p>
<a class="header" href="#kullanışlı-belgeleme-yorumları-oluşturmak" id="kullanışlı-belgeleme-yorumları-oluşturmak"><h3>Kullanışlı Belgeleme Yorumları Oluşturmak</h3></a>
<p>Paketlerinizin doğru biçimde belgelenmesi, bu paketlerin başka kullanıcılar tarafından nasıl ve ne zaman kullanılabileceğine ışık tutacağından, belgeleme sürecine zaman ayırmak önemlidir. Bölüm 3'te, Rust kodlarını iki eğik çizgi <code>//</code> kullanarak nasıl yorumlayacağımızı tartışmıştık. Bu normal yorumların yanısıra Rust, <em>belgeleme yorumları</em> olarak bilinen ve kod içinde yapılan açıklamaları, HTML belgelerine çevirmeye yarayan özel bir yorumlama biçimine sahiptir. Bu HTML belgeleri, sandığınızın nasıl <em>uygulandığını</em> anlatmaktan ziyade, nasıl <em>kullanılacağını</em> öğrenmek isteyen programcılara yol gösteren genel API öğelerinin belgelenmiş içeriğinden oluşur.</p>
<p>Belgeledikleri öğeden hemen önce yerleştirilen ve iki yerine <code>///</code> üç eğik çizgi ile ifade edilen belgeleme yorumları, metni biçimlendirmek için Markdown gösterimini destekler. Örnek 14-1, <code>sandigim</code> adlı sandıkta yer alan <code>bir_ekle</code> işlevi için belgeleme yorumlarını göstermektedir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore">
/// Kendisine iletilen sayıya bir ekler
///
/// # Örnekler
///
/// ```
/// let deger = 5;
/// let yanit = sandigim::bir_ekle(deger);
///
/// assert_eq!(6, yanit);
/// ```

pub fn bir_ekle(x: i32) -&gt; i32 {
    x + 1
}

</code></pre>
<p><span class="caption">Örnek 14-1: Bir işlevin belgelenmesi</span></p>
<p>Örnekteki <code>bir_ekle</code> işlevinin görevini anlatıp, <code>Örnekler</code> etiketli bir bölüm başlatarak <code>bir_ekle</code> işlevinin nasıl kullanılacağını gösteren kodlarla başlıyoruz. Bu işlemleri tamamladıktan sonra <code>cargo doc</code> komutunu çalıştırarak bu yorum satırlarının işlenmesiyle oluşturulan bir HTML belgesine sahip oluruz. Bu komutla oluşturulan HTML belgeleri <code>rustdoc</code> araç seti çalıştırılarak <code>target/doc</code> dizinine yerleştirilecektir.</p>
<p>Biraz daha rahatlık sağlayan <code>cargo doc --open</code> komutu ise, hem sandığınıza ait tüm bağımlılıkların HTML belgelerini oluşturacak, hem de oluşturduğu belgeleri web tarayıcınızda açarak kullanımınıza sunacaktır. Şimdi <code>bir_ekle</code> işlevine giderek, Resim 14-1'de gösterilen belgeleme yorumlarının metne nasıl dönüştürüldüğünü inceleyebilirsiniz:</p>
<p><img alt="`my_crate` sandığında `bir_ekle` işlevi için oluşturulmuş HTML belgeleri" src="https://raw.githubusercontent.com/rustdili/dokuman/master/ceviriler/img/trpl14-01.png" class="center" /></p>
<p><span class="caption">Resim 14-1: <code>bir_ekle</code> işlevinin HTML belgeleri</span></p>
<a class="header" href="#yaygın-olarak-kullanılan-bölümler" id="yaygın-olarak-kullanılan-bölümler"><h4>Yaygın Olarak Kullanılan Bölümler</h4></a>
<p>HTML belgesinde <code># Örnekler</code> başlıklı bir bölüm oluşturabilmek için Örnek 14-1'de <code># Örnek</code> şeklinde bir Markdown başlığı sözdizimi kullandık. Pek çok sandık yazarının belgelerinde yaygın olarak kullandığı bazı bölümler ise aşağıda sıralanmaktadır:</p>
<ul>
<li><strong>Panikler:</strong> Belgelenen işlevin panik üretebileceği senaryolar. İşlevin çağrıldığı programlarda panik üretmesi istenmiyorsa, kullanıcıların bu senaryoların gerçekleşebileceği durumlarda işlevi çağırmadıklarından emin olunmalıdır.</li>
<li><strong>Hatalar:</strong> İşlev bir <code>Result</code> türü döndürdüğünde, oluşması muhtemel hata çeşitlerinin ve bu hataların döndürülme neden ve koşullarının tanımlanması, işlevi çağıran tarafların farklı türden hataları farklı şekillerde işlemelerini sağlayacak şekilde kod üretmelerine yardımcı olabilir.</li>
<li><strong>Güvenlik:</strong> Eğer işlev çağrısı <code>unsafe</code> yani emniyetsiz bir çağrı ise (Rust'ın emniyetsiz kullanım seçeneğini Bölüm 19'da tartışacağız), işlevin güvensiz olma nedenlerini açıklayan ve çağıran tarafların desteklemesi gereken değişmezleri kapsayan bir bölüm olmalıdır.</li>
</ul>
<p>Çoğu belgelendirme çalışmasında bu bölümlerin her birinin yorumlanmasına ihtiyaç duyulmaz. Bununla birlikte bu bölümler kodlarınızı çağıran tarafların bilmek isteyeceği yönleri hatırlamanız amacıyla tavsiye edilen bir kontrol listesidir.</p>
<a class="header" href="#test-amaçlı-belgeleme-yorumları" id="test-amaçlı-belgeleme-yorumları"><h4>Test Amaçlı Belgeleme Yorumları</h4></a>
<p>Belgeleme yorumlarınıza örnek kod blokları eklemek, kütüphanenizin nasıl kullanılacağını göstermenize yardımcı olabileceği gibi ek bir avantaj olarak <code>cargo test</code> komutu çalıştırıldığında kod örneklerinizin test edilmesine olanak sağlar. Hiçbir şey test edilebilecek örnekler içeren belgelerden daha iyi olamaz. Ancak, belgeleme sonrası gerçekleşen kod değişiklikleri yüzünden işe yaramayan örneklerden daha kötü bir şey de yoktur. Örnek 14-1'deki <code>bir_ekle</code> işlevi için oluşturduğumuz belgeleme koduna <code>cargo test</code> komutunu uyguladığımızda, aşağıdakine benzer bir test sonucu göreceğiz:</p>
<pre><code class="language-test">
   Doc-tests sandigim

running 1 test
test src/lib.rs - bir_ekle (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>Bu aşamada işlev ya da örnek değiştirilecek olursa, örnekteki <code>assert_eq!</code> ifadesi panik üreteceğinden <code>cargo test</code> komutu tekrar çalıştırıldığında, test sürecinin örnek ve kod bölümlerinin uyumsuzluğunu fark ettiğini gözlemleyeceğiz.</p>
<a class="header" href="#İçerilen-Öğelerin-yorumlanması" id="İçerilen-Öğelerin-yorumlanması"><h4>İçerilen Öğelerin Yorumlanması</h4></a>
<p>Bir başka belgeleme biçimi olan <code>//!</code> ise, yorum satırlarının hemen altına eklenenen öğeleri belgelemek yerine, yorumun ait olduğu, yani içerildiği öğeyi belgelemek için kullanılır. Bu tarz yorum satırlarını genellikle sandık veya modülün tamamını bir bütün olarak belgelemek amacıyla, kök dosyasının içinde (kural gereği src/lib.src) ya da bir modül içerisinde kullanırız.</p>
<p>Örnek 14-2'de gösterildiği gibi, eğer daha önce oluşturduğumuz ve <code>bir_ekle</code> işlevini içeren <code>sandigim</code> için, bu sandığın amacını açıklayan belgeler eklemek istiyorsak, bunları <em>src/lib.rs</em> dosyasının en başına <code>//!</code> işaretini kullanarak eklememiz gerekir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore">
//! # Sandigim
//!
//! `Sandigim`, bazı hesaplamaların daha kolay yapılmasını
//! sağlayan araçlar koleksiyonudur.

/// Kendisine iletilen rakama 1 ekler.
// --snip--
#///
#/// # Örnekler
#///
#/// ```
#/// let rakam = 5;
#/// let yanit = sandigim::bir_ekle(rakam);
#///
#/// assert_eq!(6, yanit);
#/// ```
#pub fn add_one(x: i32) -&gt; i32 {
#    x + 1
#}

</code></pre>
<p><span class="caption">Örnek 14-2: Bir bütün olarak <code>Sandigim</code> belgeleri</span></p>
<p><code>//!</code> işaretiyle başlayan son satırın altında herhangi bir kod satırının bulunmadığına ve bir satırın boş bırakılmış olduğuna dikkat edin! Bunun sebebi, içerilen belge yorumlarını <code>///</code> yerine, <code>//!</code> işaretiyle başlattığımızdan sonraki satırlarda bulunan öğeler yerine, işaretin bulunduğu satırdaki öğelerin belgelenecek olmasıdır. Bu durumda bu yorumu içeren öğe, sandık kökümüz olan <em>src/lib.rs</em> dosyası olacağından, bu yorumlar da sandığın tamamı için yapılan açıklamaları içerecektir.</p>
<p>Eğer <code>cargo doc --open</code> komutunu çalıştırırsak, işaretlemiş olduğumuz bu yorum satırları, tıpkı Şekil 14-2'de gösterildiği gibi <code>sandigim</code> belgesinin ön sayfasında, sandıktaki genel öğeler listesinin üstünde görüntülenecektir:</p>
<p><img alt="Sandığın tamamını içeren yorumlarla oluşturulmuş HTML belgeleri" src="https://raw.githubusercontent.com/rustdili/dokuman/master/ceviriler/img/trpl14-02.png" class="center" /></p>
<p><span class="caption">Resim 14-2: <code>Sandigim</code>'ın tamamını içeren yorumlarla oluşturulmuş HTML belgeleri</span></p>
<p>Öğelerdeki belge yorumları, özellikle sandık ve modülleri tanımlamak için kullanışlıdır. Bu yorumları, paketlerinizi kullanacak olan kişilerin paket düzeninizi anlamalarına yardımcı olmak ve paket kapsamının genel amacını açıklamak için kullanmanız önemlidir.</p>
<a class="header" href="#uygun-bir-genel-apiyi-pub-use-ile-dışa-aktarmak" id="uygun-bir-genel-apiyi-pub-use-ile-dışa-aktarmak"><h3>Uygun Bir Genel API'yi <code>pub use</code> ile Dışa Aktarmak</h3></a>
<p>Bölüm 7'de kodlarımız, <code>mod</code> anahtar kelimesini kullanarak modüller halinde nasıl düzenleyeceğinizi, <code>pub</code> anahtar sözcüğüyle öğelerin nasıl genelleştirileceğini ve <code>use</code> anahtar kelimesiyle de öğelerin kapsama nasıl dahil edileceğini incelemiştik. Ancak, bir sandığın geliştirilme sürecinde sizin için anlamlı olan organizasyon yapısı, kullanıcılarınız için çok uygun olmayabilir. Sandığınızı çok katmanlı ve hiyerarşik bir yapıda düzenlediğinizde, bu hiyerarşinin alt katmanlarında tanımlanmış bir türü kullanmak isteyen kişiler, bu türe erişmekte sorun yaşayabilirler. Hem ayrıca bir türe <code>use sandigim::KullanisliBirTur;</code> şeklinde bir söz dizimiyle ulaşmak yerine,  <code>sandigim::bir_modul::baska_bir_modul::KullanisliBirTur;</code> şeklinde bir söz dizimiyle ulaşmak oldukça rahatsız edici olabilir.</p>
<p>Bir sandık yayınlarken herkese açık olarak tasarlanmış olan API'nizin yapısı oldukça önemlidir. Sandığınızı kullanan kişiler bu yapıya sizin kadar aşina olmadıklarından, sandığınız büyüyüp karmaşık bir <em>modüller hiyerarşisine</em> dönüştüğünde, kullanmak istedikleri API parçalarına ulaşmakta zorluk çekebilirler.</p>
<p>İyi haber şu ki, eğer organizasyon yapınız başkaları tarafından farklı kütüphaneler ile kullanılamayacak gibiyse, API hiyerarşisini veya tasarımını baştan sona yeniden düzenlemek yerine, <code>pub use</code> anahtar kelimesini kullanarak, bu yapının genel kullanıma uygun bir sürümünü tüm öğeleriyle birlikte yeniden ihraç edebilirsiniz. Yeniden ihraç işleminde, bir konumda bulunan genel bir öğe yerinden alınarak, sanki başka bir yerde ve başka bir konumda tanımlanmış gibi herkese açık hale getirilir.</p>
<p>Örnek 14-3'te de görüleceği gibi, sanatsal kavramları modellemek için <code>sanat</code> adında bir kütüphane tasarladığımızı varsayalım. Ve bu kütüphanenin içinde <code>BirincilRenk</code> ve <code>IkincilRenk</code> olarak isimlendirilmiş iki sıralamadan <em>(enum)</em> oluşan <code>turler</code> modülü ve <code>karisim</code> adında bir işlev içeren <code>araclar</code> modülü bulunsun:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">//! # Sanat
//!
//! Sanatsal kavramları modellemek için bir kütüphane.

pub mod turler {
    /// RYB renk modeline göre ana renkler.
    pub enum BirincilRenk {
        Kizil,
        Sari,
        Mavi,
    }

    /// RYB renk modeline göre ikincil renkler.
    pub enum IkincilRenk {
        Portakal,
        Yesil,
        Mor,
    }
}

pub mod araclar {
    use crate::turler::*;

    /// İkincil bir renk oluşturmak için iki ana rengi
    /// eşit miktarda birleştirir.
    pub fn karisim(c1: BirincilRenk, c2: BirincilRenk) -&gt; IkincilRenk {
        // --snip--
#        IkincilRenk::Portakal
#    }
#}

fn main() {}
</code></pre></pre>
<p><span class="caption">Örnek 14-3: <code>turler</code> ve <code>araclar</code> modülleri halinde düzenlenmiş öğeler içeren bir <code>sanat</code> kütüphanesi</span></p>
<p>Resim 14-3, Bu sandık için<code>cargo doc</code> tarafından üretilen belgenin ön yüzünü göstermektedir:</p>
<p><img alt="`turler` ve `araclar` modüllerini örnekleyen `sanat` sandığı için oluşturulmuş belgeler" src="https://raw.githubusercontent.com/rustdili/dokuman/master/ceviriler/img/trpl14-03.png" class="center" /></p>
<p><span class="caption">Resim 14-3: <code>turler</code> ve <code>araclar</code> modüllerini örnekleyen <code>sanat</code> sandığının ön yüzü</span></p>
<p>Belgenin ön sayfasında <code>BirincilRenk</code> ve <code>IkincilRenk</code> türleriyle <code>karisim</code> işlevinin listelenmediğine dikkat edin. Onların görüntülenebilmesi için <code>turler</code> ve <code>araclar</code> bağlantılarının açılması gerekir.</p>
<p>Bu kütüphaneye bağımlı olan başka bir sandığın, halihazırda tanımlanmış olan <code>sanat</code> modül yapısına ait öğeleri kendi kapsamına alabilmesi için <code>use</code> ifadesini kullanması gerekir. Örnek 14-4, <code>sanat</code> sandığındaki <code>BirincilRenk</code> ve <code>karisim</code> öğelerini kullanan başka bir sandık örneğini göstermektedir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore">
use sanat::turler::BirincilRenk;
use sanat::araclar::karisim;

fn main() {
    let kizil = BirincilRenk::Kizil;
    let sari = BirincilRenk::Sari;
    karistir(kizil, sari);
}

</code></pre>
<p><span class="caption">Örnek 14-4: İç yapısı dışa aktarılan sanat sandığının öğelerini kullanan başka bir sandık</span></p>
<p>Örnek 14-4'te yer alan <code>sanat</code> sandığını kullanan kodun programcısı, <code>BirincilRenk</code> türünün <code>turler</code> modülünde ve <code>karisim</code> işlevinin de  <code>araclar</code> modülünde olduğunu anlayabilmelidir. Sandığın modül yapısı, <code>sanat</code> sandığını geliştiren programcılardan çok, bu sandığı kullanan  programcılar için önemlidir. Sandığın parçalarını <code>turler</code> ve <code>sanat</code> modülleri olarak düzenleyen iç yapı, bu sandığın nasıl kullanılacağını öğrenmek isteyenler için herhangi bir yararlı bilgi içermediği gibi, <code>sanat</code> sandığı modül yapısının yarattığı karmaşa, <code>use</code> ifadelerinde modül adlarını belirtmek isteyen kullanıcıların nereye bakacaklarını karıştırmalarına neden olacağından kullanışsız bir yapıdır.</p>
<p>Herkesin kullanacağı bu API'nin sorunlu iç düzenlemesini <code>pub use</code> kullanarak kaldırıp, öğeleri en üst düzeyde yeniden dışa aktarabilmek için, Örnek 14-3'te yer alan <code>sanat</code> sandığının kodlarını, Örnek 14-5'te gösterildiği şekilde yeniden düzenleyebiliriz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore">
//! # Sanat
//!
//! Sanatsal kavramları modellemek için bir kütüphane.

pub use self::araclar::karisim;
pub use self::turler::BirincilRenk;
pub use self::turler::IkincilRenk;

pub mod turler {
    // --snip--
#    /// RYB renk modeline göre ana renkler.
#    pub enum BirincilRenk {
#        Kizil,
#        Sari,
#        Mavi,
#    }
#
#    /// RYB renk modeline göre ikincil renkler.
#    pub enum IkincilRenk {
#        Portakal,
#        Yesil,
#        Mor,
#    }
}

pub mod araclar {
    // --snip--
#    use crate::turler::*;
#
#    /// İkincil bir renk oluşturmak için iki ana rengi
#    /// eşit miktarda birleştirir.
#    pub fn karisim(c1: BirincilRenk, c2: BirincilRenk) -&gt; IkincilRenk {
#        IkincilRenk::Portakal
#    }
}
#
#fn main() {}

</code></pre>
<p><span class="caption">Örnek 14-5: Öğeleri yeniden dışa aktarmak için <code>pub use</code> ifadesi eklemek</span></p>
<p>Şekil 14-4'te görebileceğiniz gibi <code>cargo doc</code> komutunun bu sandık için oluşturduğu API belgeleri, dışa aktarımları yeniden ön sayfada listeleyerek bağlayacak, <code>BirincilRenk</code> ve <code>IkincilRenk</code> türleriyle <code>karisim</code> işlevinin bulunmasını oldukça kolaylaştıracaktır.</p>
<p><img alt="`sanat` sandığının yeniden dışa aktarımıyla oluşan belgelerin ön sayfası" src="https://raw.githubusercontent.com/rustdili/dokuman/master/ceviriler/img/trpl14-04.png" class="center" /></p>
<p><span class="caption">Resim 14-4: Yeniden dışa aktarımı örnekleyen <code>sanat</code> sandığının ön yüzü</span></p>
<p>Artk <code>sanat</code> sandığını kullanmak isteyen programcılar, ister hâlâ kullanılmaya uygun durumdaki Örnek 14-3 ve Örnek 14-4'ün iç yapılarını inceleyerek kodlarına bunları dahil edebilirler, isterlerse Örnek 14-5 ve 14-6'da yenilenerek kullanıma daha uygun hale getirilen yapıyı tercih edebilirler.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">
use sanat::karisim;
use sanat::BirincilRenk;

fn main() {
    // --snip--
#    let kizil = BirincilRenk::Kizil;
#    let sari = BirincilRenk::Sari;
#    karisim(kizil, sari);
}

</code></pre>
<p><span class="caption">Örnek 14-6: <code>sanat</code> sandığının yeniden dışa aktarılan öğelerini kullanan bir program</span></p>
<p>İç içe geçmiş çok sayıda modülü, türleri <code>pub use</code> ifadesiyle en üst düzeyde yeniden dışa aktarmak, sandığı kullanacak kişilerin deneyimlerinde önemli farklar yaratabilir.</p>
<p>Kullanışlı bir genel API tasarımı oluşturmak bilimden çok sanat olarak kabul edildiğinden, kullanıcılarınız için en iyi çalışacak uygun bir düzenleme için defalarca tekrar yapmanız gerekebilir. Bununla birlikte <code>pub use</code> kullanımını seçmek, sandığınızın iç düzenlemesinde size esneklik sağlarken, bu iç düzeni kullanıcılarınıza sunduğunuz arayüzden ayırır. Kurduğunuz bazı sandıkların iç düzenlemelerinin genel API katmanlarına göre farklarını incelemek için bu sandıkların kodlarına bakmanız öğretici olacaktır.</p>
<a class="header" href="#cratesio-hesabı-oluşturmak" id="cratesio-hesabı-oluşturmak"><h3>Crates.io Hesabı Oluşturmak</h3></a>
<p>Herhangi bir sandığı yayınlayabilmeniz için öncelikle <a href="https://crates.io/">crates.io</a> üzerinde bir hesap oluşturmanız ve bir API anahtarı almanız gerekir. Bunun için <em>(Her ne kadar gelecekte siteye başka yöntemlerle üye olunması planlanmış olsa da şu an için yalnızca GitHub hesaplarımız ile giriş kabul edildiğinden)</em> <a href="https://crates.io/">crates.io</a> adresini ziyaret ederek GitHub hesabınız ile giriş yapın. Ardından, <a href="https://crates.io/me/">https://crates.io/me/</a> adresindeki hesap ayarlarınızı gözden geçirerek API anahtarınızı alın. Aldığınız bu API anahtarını <code>cargo login</code> komutuna ekleyerek tıpkı aşağıda örneklendiği gibi çalıştırın:</p>
<pre><code class="language-console">
$ cargo login abcdefghijklmnopqrstuvwxyz012345

</code></pre>
<p>Bu komut API anahtarınızı Cargo'ya bildirecek ve yerel olarak onu <em>~/.cargo/credentials</em> içinde depolayacaktır. Anahtarınızın <em>size özel</em> olduğunu, <em>gizli</em> kalması ve kimseyle paylaşılmaması gerektiğini unutmayın. Eğer herhangi bir sebeple anahtarınızı birileriyle paylaşmak zorunda kalırsanız, eskisini derhal iptal ederek yeni bir anahtar oluşturun.</p>
<a class="header" href="#yeni-oluşturulmuş-sandığa-meta-veri-eklemek" id="yeni-oluşturulmuş-sandığa-meta-veri-eklemek"><h3>Yeni Oluşturulmuş Sandığa Meta Veri Eklemek</h3></a>
<p>Artık hesabınızı oluşturduğunuza göre, yayınlamak istediğiniz bir sandığınız olduğunu düşünebiliriz. Ancak sandığınızı yayınlamadan önce, <em>Cargo.toml</em> dosyasının <code>[package]</code> bölümüne sandığınıza ait meta veriler eklemeniz gerekir.</p>
<p>Bir sandık üzerinde yerel olarak çalışırken onu istediğiniz gibi adlandırabilirsiniz. Ancak sandığınız yayın aşamasına geldiğinde benzersiz bir isme ihtiyacı olacak. <a href="https://crates.io/">crates.io</a>'daki sandık isimlerinde öncelik ilk gelene verildiğinden, bir isim bir sandığa tahsis edildikten sonra başka bir sandığa tahsis edilemez. Başka bir ifadeyle, sandık adı bir kez alındığında aynı isimde başka bir sandık yayınlanamaz. O yüzden sandığınızı <a href="https://crates.io/">crates.io</a> üzerinde yayınlanmadan önce, sandık adınızı kullanan başka bir sandık olup olmadığını araştırmalısınız. Eğer sandık adınız halihazırda başka bir sandık tarafından kullanılmakta ise, yenileyeceğiniz sandık adını, paketinizin <em>Cargo.toml</em> dosyasında bulunan <code>[package]</code> bölümüne, isim alanıyla birlikte aşağıda gösterildiği gibi girmeniz gerekir.</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">
[package]
name = &quot;tahmin_oyunu&quot;

</code></pre>
<p>Her ne kadar benzersiz bir ad seçmiş olsanız bile, sandığı yayınlamak için <code>cargo publish</code> komutunu çalıştırdığınızda aşağıdakine benzer bir uyarı ve hata alabilirsiniz:</p>
<pre><code class="language-console">
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata


</code></pre>
<p>Bunun sebebi, sandığınızı kullanmak isteyecek programcılar için hazırlamanız gereken, sandığınızın neler yaptığını ve hangi koşullar altında kullanılabileceğini düzenleyen açıklama ve lisans bilgileri gibi önemli detayları atlamış olmanızdır. Bu hatayı düzeltmek için gerekli olan bilgileri paketinizin <em>Cargo.toml</em> dosyasına işlemeniz gerekir.</p>
<p>Girdiğiniz açıklamalar arama sonuçlarında görüntüleneceğinden, en azından bir iki cümlelik açıklama eklemeniz yerinde olur. Lisans alanı içinse bir <code>license</code> tanımlayıcı değeri vermeniz gereklidir. <a href="http://spdx.org/licenses/">Linux Vakfı'nın Yazılım Paketi veri değişimi (SPDX)</a>, bu alan için kullanabileceğiniz tanımlayıcıları listeler. Örneğin, sandığınızı MIT Lisansı ile lisansladığınızı belirtmek için <code>MIT</code> tanımlayıcısını eklemeniz gerekir:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">
[package]
name = &quot;tahmin_oyunu&quot;
license = &quot;MIT&quot;

</code></pre>
<p>SPDX'te listelenmemiş bir lisans kullanmak istiyorsanız, söz konusu lisansın metnini bir dosyaya yerleştirmeniz, dosyayı projenize eklemeniz ve ardından <code>license</code> alanındaki tanımı <code>license-file</code> şeklinde dosya adını tanımlayacak şekilde belirtmeniz gerekmektedir.</p>
<p>Projeniz için hangi lisansın daha uygun olacağına dair rehberlik bu kitabın kapsamı dışındadır. Rust topluluğunun pek çok üyesi projelerini, Rust'ın tercih ettiği gibi <code>MIT OR Apache-2.0</code> olarak çifte lisans kullanarak sunar. Bu uygulama biçimi projenizi <code>OR</code> ekiyle birden fazla lisansa sahip olacak şekilde lisans tanımlayıcısıyla ilişkilendirebileceğinizi gösterir.</p>
<p>Benzersiz bir isim seçtiğiniz sandığınıza; yazar adı, sürüm bilgisi, paket açıklaması ve lisans bilgileri eklendikten sonra, yayına hazır hale gelen projenizin <code>Cargo.toml</code> dosyası aşağıdaki dosya gibi görünecektir:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">
[package]
name = &quot;tahmin_oyunu&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Rust Dili &lt;rustdili@gmail.com&gt;&quot;]
edition = &quot;2018&quot;
description = &quot;Bilgisayarın seçtiği sayıyı tahmin ederken eğleneceğiniz keyifli bir oyun.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]

</code></pre>
<p>Sandıklarınızın kolaylıkla fark edilip kullanabilmesi için değerlendirebileceğiniz meta verilere <a href="https://doc.rust-lang.org/cargo/">Cargo Belgeleri</a> üzerinden kolaylıkla ulaşabilirisiniz.</p>
<a class="header" href="#bir-sandığı-cratesioda-yayınlamak" id="bir-sandığı-cratesioda-yayınlamak"><h3>Bir sandığı Crates.io'da Yayınlamak</h3></a>
<p>Artık bir hesabınız, API anahtarınız, benzersiz ada sahip bir sandığınız olduğuna ve bu sandığa gerekli meta verileri eklediğinize göre sandığızı yayınlamaya hazırsınız demektir. Bir sandığı yayınlamak demek, sandığınızın belirli bir sürümünü başka kullanıcılar için <a href="https://crates.io/">crates.io</a> sitesine yüklemek anlamına gelir.</p>
<p><a href="https://crates.io/">Crates.io</a>'nun asıl hedeflerinden biri yayınlanan sandıklara bağımlı tüm projelerin çalışmaya devam edebilmesi için kalıcı bir kod arşivi oluşturmaktır. Bu nedenle bir sandık yayınlandıktan sonra, yayınlanan sürümün üzerinde ekleme, düzenleme yahut silme gibi işlemler artık yapılamayacağından, sandık yayınlarken dikkatli olunması gerekir. Sürüm silme işlemine izin vermek bu hedefi imkansızlaştıracağından, sürüm silmek yerine sandığın başka sürümlerinin yayınlaması yeğlenir. O nedenle bir sandığa ait sürümlerin yayın sınırı yoktur.</p>
<p>Şimdi <code>cargo publish</code> komutunu tekrar çalıştırdığınızda paketinizin başarıyla yayınlandığını göreceksiniz:</p>
<pre><code class="language-console">
$ cargo publish
    Updating crates.io index
   Packaging tahmin_oyunu v0.1.0 (file:///projem/tahmin_oyunu)
   Verifying tahmin_oyunu v0.1.0 (file:///projem/tahmin_oyunu)
   Compiling tahmin_oyunu v0.1.0
(file:///projem/tahmin_oyunu/target/package/tahmin_oyunu-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading tahmin_oyunu v0.1.0 (file:///projem/tahmin_oyunu)

</code></pre>
<p>Tebrikler! Artık kodunuzu Rust topluluğuyla paylaştığınıza göre, herkes sizin sandığınızı kendi projesine bağımlılık olarak kolayca ekleyebilir.</p>
<a class="header" href="#mevcut-sandığın-yeni-sürümünü-yayınlamak" id="mevcut-sandığın-yeni-sürümünü-yayınlamak"><h3>Mevcut Sandığın Yeni Sürümünü Yayınlamak</h3></a>
<p>Daha önce yayınladığınız bir sandık üzerinde tüm kullanıcıları etkileyebilecek değişiklikler yaptığınızda ya da sandığınızın yeni sürümünü yayınlamak istediğinizde, <em>Cargo.toml</em> dosyasında belirtilen sürüm değerini değiştirerek yeniden yayınlayabilirsiniz. Yaptığınız değişiklik türlerine bağlı olarak, sonraki sürümün numarasına karar verirken <a href="http://semver.org/">Anlamsal Sürüm Oluşturma Kuralları</a> sitesini kullanabilirsiniz. Yeni sürümünüzü, düzenlemelerinizi gerçekleştirdikten sonra <code>cargo publish</code> komutunu kullanarak yayınlayabilirsiniz.</p>
<a class="header" href="#sürümleri-cratesiodan-cargo-yank-komutu-kullanarak-kaldırmak" id="sürümleri-cratesiodan-cargo-yank-komutu-kullanarak-kaldırmak"><h3>Sürümleri Crates.io'dan <code>cargo yank</code> Komutu Kullanarak Kaldırmak</h3></a>
<p>Yayımlanmış bir sandığın önceki sürümlerini kaldıramıyor olsanız bile, bir sebepten sandık sürümünüz bozulmuşsa, yeni projelerin bu sürümleri kullanmasını ve bağımlılık olarak eklemesini engelleyebilirsiniz. Cargo'nun böyle durumlarda kullanılan <code>yank</code> komutu ilgili sürümün geri çekilmesini sağlar.</p>
<p>Bir sürümün geri çekilmesi, yeni projelerin bu sürüme bağlanmasını önlerken, halihazırda kendisine bağımlı olan projelerin bu sürümü indirmesine ve bağımlı olarak çalışmasına izin verir. Temel olarak <code>yank</code>, yani geri çekme işlemi, <em>Cargo.lock</em> dosyasına işlenmiş projelerin bozulmadan kullanılmaya devam edeileceğini, ama yeni bağımlılık taleplerinde bu sürümün kullanılmasına izin verilmeyeceği anlamına gelmektedir.</p>
<p>Geri çekilmek istenen sandık sürümü için <code>cargo yank</code> komutunun aşağıda örneğe benzer biçimde kullanılması gerekir:</p>
<pre><code class="language-console">
$ cargo yank --vers 1.0.1

</code></pre>
<p>Bu geri çekme işlemini <code>cargo yank</code> komutuna <code>--undo</code> ekleyerek geçersiz hale getirebilir ve projelerin bu sürüme yeniden bağlanmasına izin verebilirsiniz:</p>
<pre><code class="language-console">
$ cargo yank --vers 1.0.1 --undo

</code></pre>
<p>Geri çekme işlemi halihazırda var olan kodları silmez. Eğer projenize yanlışlıkla eklediğiniz bazı özel veya sır olarak kalması gereken kodlar varsa ve bu kodları <code>yank</code> kullanarak silmek istiyorsanız, bunu yapmanız mümkün olamayacağından, sürümünüzü yayınlamadan önce bu kodları sıfırlamanız veya kaldırmanız gerekir.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch14-01-release-profiles.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch14-03-cargo-workspaces.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch14-01-release-profiles.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch14-03-cargo-workspaces.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
