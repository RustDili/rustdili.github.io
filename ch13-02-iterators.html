<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yineleyiciler ile Bir Dizi Öğeyi İşlemek - Rust Programlama Dili</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust Programlama Dili Resmi Kitabı Türkçe çevirisi">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="title-page.html">Rust Programlama Dili</a></li><li class="affix"><a href="foreword.html">Önsöz</a></li><li class="affix"><a href="ch00-00-introduction.html">Giriş</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Kurulum</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Bir Tahmin Oyunu Programlamak</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Ortak Programlama Kavramları</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişkenlik</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> İşlevler</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorumlar</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Mülkiyeti Anlamak</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Mülkiyet Nedir?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Borçlanma</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlişkili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklemek</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Sözdizimi</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Sıralamalar ve Örüntü Eşleme</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Bir Sıralama Tanımlamak</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Kontrol Akışı İşleci match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akışı</a></li></ol></li><li><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Sandıklar ve Modüller ile Yönetmek</a></li><li><ol class="section"><li><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Sandıklar</a></li><li><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Kapsam ve Gizlilik Kontrolü İçin Modül Tanımlamak</a></li><li><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki Bir Öğeye Başvurmanın Yolları</a></li><li><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Anahtar Kelimesi ile Yolları Kapsama Getirmek</a></li><li><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Ortak Koleksiyonlar</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Değer Listelerini Vektör Kullanarak Depolamak</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Dizgelerle UTF-8 Kodlu Metinleri Saklamak</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlere Sahip Anahtarları Eşleme Haritalarında Saklamak</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamaz Hatalar</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! Olmak ya da panic! Olmamak</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Genellenmiş Türler, Özellikler ve Yaşam Süreleri</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Genellenmiş Veri Türleri</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Özellikler: Paylaşılan Davranışı Tanımlamak</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referansları Yaşam Süreleri ile  Doğrulamak</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatik Testler Yazmak</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır?</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştırılacağını Denetlemek</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir I/O Projesi: Komut Satırı Programı Oluşturmak</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Kabul Etmek</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Bir Dosyayı Okumak</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerlik ve Hata Yönetimini Geliştirmek İçin Yeniden Düzenlemek</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphane İşlevselliğini Artırmak</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenleriyle Çalışmak</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı Yerine Standart Hataya Yazmak</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> İşlevsel Dil Özellikleri: Yineleyiciler ve Kapamalar</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapamalar: Ortam Değişkenlerini Yakalayabilen İsimsiz İşlevler</a></li><li><a href="ch13-02-iterators.html" class="active"><strong aria-hidden="true">13.2.</strong> Yineleyiciler ile Bir Dizi Öğeyi İşlemek</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O Projemizi Geliştirmek</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Karşılaştırması: Döngüler vs. Yineleyiciler</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Sürüm Profilleriyle Derlemeleri Özelleştirmek</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Bir Sandığı Crates.io Üzerinde Yayınlamak</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Crates.io Üzerindeki İkili Sandıkları cargo install Komutuyla Yüklemek</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo Olanaklarını Genişletmek</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Heap Üzerindeki Verilere İşaret Etmek İçin Box<T> Kullanmak</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Özelliği ile Akıllı İşaretçilere Normal Referanslar Gibi Davranmak</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Özelliği ile Kodu Temizlik Amaçlı Çalıştırmak</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, Referans Sayılı Akıllı İşaretçi</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> ve İç Değişkenlik Modeli</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Çevrimleri Bellek Sızıntısına Yol Açabilir</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Eşzamanlı Kod Çalıştırmak İçin İşlikleri Kullanmak</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> İşlikler Arasında Veri Aktarmak Amacıyla Mesajlaşma</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Durum Paylaşımlı Eşzamanlılık</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync and Send Özellikleri ile Genişletilebilir Eşzamanlılık</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'ın Nesne Yönelimli Programlama Özellikleri</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Özellikleri</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türden Değerlere İzin Veren Özellik Nesnelerini Kullanmak</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesne Yönelimli Tasarım Kalıbı Uygulamak</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Örüntü ve Eşleme</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Örüntüler Her Yerde Kullanılabilir</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Çürütülebilirlik: Bir Örüntünün Eşleşmeme İhtimali</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Örüntü Sözdizimi</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Emniyetsiz Rust</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Özellikler</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelişmiş İşlev ve Kapamalar</a></li><li><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çok İşlikli Web Sunucusu Oluşturmak</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İşlikli Bir Web Sunucusu Oluşturmak</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İşlikli Sunucumuzu Çok İşlikli Bir Sunucuya Dönüştürmek</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Sorunsuzca Kapatmak ve Temizlik</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ekler</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Kelimeler</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - İşleçler ve Semboller</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Özellikler</a></li><li><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Faydalı Geliştirme Araçları</a></li><li><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitabın Çevirileri</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust Nasıl “Nightly Rust” Yapılır? </a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Programlama Dili</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/RustDili/dokuman/tree/master/ceviriler" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#yineleyiciler-ile-bir-dizi-Öğeyi-İşlemek" id="yineleyiciler-ile-bir-dizi-Öğeyi-İşlemek"><h2>Yineleyiciler ile Bir Dizi Öğeyi İşlemek</h2></a>
<p>Bir koleksiyonun tüm elemanları tükenene kadar her bir elemanı üzerinde sırasıyla belirli işlemleri gerçekleştirmekten yineleyiciler sorumludurlar. Yineleyici kullandığınızda bütün bu işlemlerin her birini tekrar tekrar gerçekleştirmek zorunda kalmazsınız.</p>
<p>Rust’ta yineleyiciler tembel olduklarından, kendilerini tüketen yöntemler çağırılana kadar programlarınızı etkilemezler. Örneğin aşağıdaki kod; <code>Vec&lt;T&gt;</code> üzerinde tanımlanan <code>iter</code> yöntemini çağırarak <code>v1</code> vektöründeki öğeler üzerinde bir yineleyici oluşturur. Bu kod tek başına anlamlı bir şey gerçekleştirmez.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
}
</code></pre></pre>
<p><span class="caption">Örnek 13-13: Bir yineleyici oluşturmak</span></p>
<p>Bir yineleyici oluşturduktan sonra artık bunu çeşitli şekillerde kullanabiliriz. Bölüm 3’ün sonlarında yer alan örnek 3-5’te, her eleman üzerinde bir takım işlemleri gerçekleştirmek amacıyla <code>for</code> döngüsünün tüketimine verilen <code>iter</code> tanımlamasıyla yineleyici kullanmış, ancak yineleyicilere şu ana kadar derinlemesine odaklanamamıştık.</p>
<p>Aşağıdaki örnekte, yineleyicinin oluşturulması ile <code>for</code> döngüsünde kullanımı birbirinden bağımsız olarak sunulmaktadır. Kendi başına <code>v1_iter</code> değişkeninde saklanan yineleyicinin tanımlandığı satırda hiç bir işlem gerçekleşmezken, bu değişkene adapte edilmiş yineleyiciyi kullanan bir <code>for</code> döngüsü ile çağrıldığında, kendisine geçirilmiş olan her öğenin değerini ekrana yazdıran bir döngü yineleyicisi olarak kullanışlı hale gelir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;Okunan: {}&quot;, val);
    }
}
</code></pre></pre>
<p><span class="caption">Örnek 13-14: Bir yineleyici <code>for</code> döngüsünde kullanmak</span></p>
<p>Standart kitaplıklarında yineleyici bulunmayan dillerde bu tarz bir işlev, olasılıkla dizinin ilk elemanıyla değerinin arttırıldığı bir sayaç değişkeniyle başlatılacak, dizinin sonuna erişilene kadar her eleman için değişken birer birer güncellenerek işletilecektir.</p>
<p>Oysa yineleyiciler bütün bu karmaşık sayım sürecindeki mantığı sizin için üstlenebilir, muhtemel kod tekrarlarını azaltarak potansiyel karışıklıkların üstesinden gelebilirler. Yineleyiciler sadece vektörler gibi indekslenebilir veri yapılarıyle değil, aynı mantığın uygulandığı pekçok farklı koleksiyon türüyle kullanılılırken de fazlasıyla esnektirler. Haydi yineleyicilerin bunu nasıl yaptığını birlikte inceleyelim.</p>
<a class="header" href="#iterator-Özelliği-ve-next-metodu" id="iterator-Özelliği-ve-next-metodu"><h3><code>Iterator</code> Özelliği ve <code>next</code> Metodu</h3></a>
<p>Tüm yineleyiciler standart kitaplıkta tanımlanan <code>Iterator</code> adlı bir özelliği uygular. Özelliğin tanımı şuna benzer:</p>
<pre><pre class="playpen"><code class="language-rust">#![allow(unused_variables)]
fn main() {
    pub trait Iterator {
        type Item;

        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

        // Şu an için varsayılan uygulamaları gösterilmeyen metodlar
    }
}
</code></pre></pre>
<p>Bu tanımda <code>type Item</code> ve <code>Self::Item</code> gibi bu özelliklerle ilişkilendirilmiş türü bildiren yeni söz dizimleri kullanıldığına dikkat edin. İlişkili türlerden bölüm 19’da ayrıntılı olarak bahsedeceğimizden şimdilik bilmeniz gereken tek şey; bu kodun yineleyici özelliğini <em>(<code>Itarator trait</code>)</em> uygulayabilmek için bir öğe türü <em>(<code>Item type</code>)</em> tanımlanması gerektiği ve bu öğe türünün <code>next</code> metodunun dönüş türünde kullanıldığını belirtmesidir. Başka bir deyişle öğe türü yineleyiciden döndürülen tür olacaktır.</p>
<p>Yineleyici özelliği uygulayıcılara sadece bir metodu tanımlamak için ihtiyaç duyar. Tanımlanan <code>next</code> metodu yineleme devam ettiği sürece öğeleri <code>Some</code> ile sarmalayarak birer birer döndürürken, yineleme sona erdiğinde <code>None</code> döndürecektir.</p>
<p>Yineleyicideki <code>next</code> metodunu doğrudan kendimiz de çağırabiliriz. Örnek 13-15’te, <code>v1</code> vektöründe oluşturulan yineleyiciye yapılan çağrılardan <code>next</code> metoduna hangi değerlerin döndürüldüğü gösterilmektedir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
#[cfg(test)]
mod tests {
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">Örnek 13-15: Yineleyicideki <code>next</code> metodunu çağırmak</span></p>
<p>Öncelikle <code>v1_iter</code> değişmezinin <code>mut</code> anahtar sözcüğüyle değişebilir hale dönüştürülmesi gerektiğine dikkat edin. Bir yineleyicide <code>next</code> metodunun çağrılması, yineleyicinin dizide bulunduğu yeri izlemek için kullandığı iç konumu değiştirir. Başka bir deyişle, metodu çağıran kod yineleyiciyi tüketir veya kullanır. Her <code>next</code> metodu çağrısı yineleyicide bir öğenin tüketilmesine neden olur. Oysa <code>v1_iter</code> değişkeni <code>for</code> döngüsü ile kullanıldığında, değişkenin mülkiyeti döngüye aktarıldığından, durumu perde arkasında değişebilir olarak değiştirilir ve böylelikle <code>v1_iter</code> değişmezinin değişebilir olarak dönüştürülmesine gerek duyulmaz.</p>
<p>Ayrıca <code>next</code> metodu çağrılarından aldığımız değerlerin, vektör elemanlarının değişmez referansları olduğunu ve <code>Iter</code> metodunun değişmez referanslar üzerinde bir yineleyici oluşturduğunu unutmayın. Eğer <code>v1</code> vektörünün mülkiyetini alarak, sahip olunan değerleri döndürecek bir yineleyici oluşturmak istiyorsanız, iter yerine <code>into_iter</code> metodunu çağırabilirsiniz. Benzer şekilde, değişebilir referanslar üzerinde yineleme yapmanız gerektiğinde, <code>iter</code> kullanmak yerine, <code>iter_mut</code> metodunu kullanabilirsiniz.</p>
<a class="header" href="#yineleyici-tüketen-metodlar" id="yineleyici-tüketen-metodlar"><h3>Yineleyici Tüketen Metodlar</h3></a>
<p>Standart kitaplık tarafından sağlanan <code>Iterator</code> özelliğinin varsayılan uygulaması, halihazırda bir dizi metoda sahip olduğundan, bu metodlar hakkındaki bilgilere <code>Iterator</code> özelliğinin API belgelerini inceleyerek ulaşabilirsiniz. Bu metodlardan bazıları tanımlarında bulunan <code>next</code> metodunu çağırdığından <code>Iterator</code> özelliğini uygularken bu metodu da uygulamanız gerekmektedir.</p>
<p>Bu metodunu çağıran işlevler ise çağrıları sırasında yineleyiciyi kullandıklarından onlara <em>tüketici adaptörleri</em> adı verilir. Yineleyicinin mülkiyetini alarak her öğe için <code>next()</code> metod çağırısını yineleyen ve bu esnada yineleyiciyi tüketen <code>sum</code> metodu buna iyi bir örnektir. Bu metod yineleme süresince her elemanı toplama ekleyer ve yineleme sona erdiğinde bu toplamı döndürür. Örnek 13-16 <code>sum</code> metodu kullanımını örnekleyen bir test içerir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">Örnek 13-16: Yineleyicideki tüm öğelerin toplamını alan <code>sum</code> metodunu çağırmak</span></p>
<p><code>sum</code> metodu, kendisine yapılan çağrı ile <code>v1_iter</code> değişmezindeki yineleyicinin mülkiyetini üzerine alacağından bu değişkenin kullanılmasına izin verilmez.</p>
<a class="header" href="#diğer-yineleyicileri-Üreten-metodlar" id="diğer-yineleyicileri-Üreten-metodlar"><h3>Diğer Yineleyicileri Üreten Metodlar</h3></a>
<p><code>Iterator</code> özelliğinde tanımlanan ve <em>yineleyici adaptörleri</em> adı verilen diğer yöntemler ise yineleyicileri farklı yineleyicilerle değiştirmenize olanak sağlarlar. Bu adaptörlere karmaşık eylemleri okunabilir şekilde gerçekleştirmek çok sayıda çağrı zincirleyebilirsiniz. Ancak tüm yineleyiciler tembel olduklarından, yineleyici adaptörlerine yapılan çağrılardan sonuç alabilmek için <em>tüketici adaptörleri</em>nden birini çağırmanız gerekir.</p>
<p>Örnek 13-17’de yeni bir yineleyici üretmek üzere her öğenin çağrıldığı bir kapama işlevine sahip yineleyici adaptörü olan <code>map</code> metodunun bir örneği gösterilir. Buradaki kapama işlevi vektördeki her öğe değerinin 1 arttırıldığı yeni bir yineleyici oluşturacaktır. Ancak bu kod bir uyarı vermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior">
fn main() {
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
}

</code></pre></pre>
<p><span class="caption">Bir yineleyici adaptörü olan <code>map</code> metodunu yeni bir yineleyici oluşturmak üzere çağırmak</span></p>
<p>Aldığımız uyarının çıktısı aşağıdaki gibidir:</p>
<pre><code class="language-console">
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`

</code></pre>
<p>Örnek 13-17’de yer alan kod hiçbir şey yapmadığı gibi bildirdiğimiz kapama işlevi de hiçbir zaman çağrılmaz. Yineleyici adaptörleri tembel olduklarından, derleyicinin uyarısı bize yinelecinin tüketilmesi gerektiği uyarısını yapıyor.</p>
<p>Bu durumu düzeltmek ve yineleyiciyi kullanabilmek için Bölüm 12, Örnek 12-1’de yer alan ve <code>env::args</code> ile kullandığımız <code>collect</code> metodundan yararlanacağız. Bu metod yineleyiciyi tüketerek elde ettiği değerleri bir koleksiyon veri türüne depolar.</p>
<p>Örnek 13-18’de <code>map</code> metoduna yapılan çağrı vasıtasıyla yineleyici üzerinde yapılan yinelemeden döndürülen sonuçları bir vektörde topluyoruz. Sonuçların depolandığu bu vektör, orijinal vektördeki her öğenin değerine 1 eklenmiş sayılardan oluşmaktadır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
fn main() {
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
}

</code></pre></pre>
<p><span class="caption">Örnek 13-18: Yeni bir yineleyici oluşturmak üzere <code>map</code> yöntemini ve üretilen bu yineleyiciyi vektör oluştururken tüketen <code>collect</code> yöntemini çağırmak</span></p>
<p><code>map</code> metodu bir kapama işlevi aldığından, her bir öğe için uygulamak istediğimiz herhangi bir işlemi belirtebiliriz. Bu örnek, <code>Iterator</code> özelliğinin sağladığı yineleme davranışını yeniden kullanırken, kapamaların bazı davranışları özelleştirmenize nasıl izin verdiğini gösteren harika bir örnektir.</p>
<a class="header" href="#ortamlarını-yakalayan-kapamalar-kullanmak" id="ortamlarını-yakalayan-kapamalar-kullanmak"><h3>Ortamlarını Yakalayan Kapamalar Kullanmak</h3></a>
<p>Artık yineleyicileri kullanıma sunduğumuza göre, bir yineleyici adaptörünü olan <code>filter</code> metodu kullanarak ortamlarını yakalayan kapamaların yaygın bir kullanımını gösterebiliriz. Bir yineleyicideki <code>filter</code> metodu, yineleyiciden aldığı her öğe karşılığında Boolean döndüren bir kapama işlevini kullanır. Kapama <code>true</code> döndürdüğünde, değer <code>filter</code> tarafından üretilen yineleyiciye dahil edilecek, <code>false</code> döndürdüğündeyse yineleyiciye dahil edilmeyecektir.</p>
<p>Örnek 13-19’da <code>Shoe</code> adlı yapı örneklerinden oluşan koleksiyon üzerinde yineleme yapmak üzere <code>shoe_size</code> değişkenini ortamından elde eden bir kapama işleviyle <code>filter</code> metodunu birlikte kullanıyor ve sadece belirtilen boyuttaki ayakkabıları döndürüyoruz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;Spor ayakkabı&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;Sandalet&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;Bot&quot;),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;Spor ayakkabı&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;Bot&quot;)
                },
            ]
        );
    }
}

fn main() {}

</code></pre></pre>
<p><span class="caption">Örnek 13-19: <code>shoe_size</code> değerini ortamından yakalayan bir kapama ile <code>filter</code> metodunu birlikte kullanmak</span></p>
<p><code>shoes_in_my_size</code> işlevi, parametre olarak bir ayakkabı vektörü ve bir ayakkabı numarasının mülkiyetini alarak sadece belirtilen ölçüdeki ayakkabıları içeren bir yeni vektör döndürür.</p>
<p><code>shoes_in_my_size</code> işlevinin gövdesinde vektörün mülkiyetini alacak bir yineleyici oluşturmak üzere <code>into_iter</code> metodunu çağırıyor, sonra bu yineleyiciyi, kapamanın sadece <code>true</code> döndürdüğü öğelerden oluşan yeni bir yineleyiciye uyarlayamak amacıyla <code>filter</code> metodunu kullanıyoruz.</p>
<p>Ortamdan <code>shoe_size</code> parametresini yakalayan kapama, bu değeri her bir ayakkabının numarasıyla karşılaştırarak yalnızca belirtilen ölçüdeki ayakkabıları tutar. Son olarak, <code>collect</code> çağrısı, uyarlanmış yineleyici tarafından döndürülen değerleri işlev tarafından döndürülen bir vektöre depolar.</p>
<p>Örneğimizdeki test, <code>shoes_in_my_size</code> işlevini çağırdığımızda, yalnızca belirttiğimiz ölçülere uygun ayakkabıların döndürüldüğünü göstermektedir.</p>
<a class="header" href="#iterator-Özelliği-ile-kendi-yineleyicilerimizi-oluşturmak" id="iterator-Özelliği-ile-kendi-yineleyicilerimizi-oluşturmak"><h3><code>Iterator</code> Özelliği ile Kendi Yineleyicilerimizi Oluşturmak</h3></a>
<p>Bir vektör üzerinde <code>iter</code>, <code>into_iter</code> veya <code>iter_mut</code> metodlarını çağırarak bir yineleyici oluşturabileceğinizi gösterdik. Tıpkı bu vektör için oluşturduğumuz yineleyici gibi, standart kütüphanedeki eşleme haritaları veya diğer koleksiyon türleri için de yineleyiciler hazırlayabilir, <code>Iterator</code> özelliğini kendi türlerinize uygulayarak dilediğiniz işlemleri gefçekleştiren yineleyiciler oluşturabilirsiniz. Daha önce de belirtildiği gibi, tanımlamanız gereken tek metod <code>next</code> metodu olduğundan, bu metodu tanımladığınızda, <code>Iterator</code> özelliği tarafından sağlanan varsayılan uygulamalara sahip metodların tümünü kullanabilirsiniz!</p>
<p>Bu bilgiyi pekiştirmek adına, sadece 1’den 5’e kadar sayacak bir yineleyici oluşturalım. Öncelikle bunun için, bazı değerleri tutan bir yapı oluşturacak, ardından bu yapıya <code>Iterator</code> özelliğini uygulayacak ve bu uygulamadaki değerler vasıtasıyla bu yapıyı bir yineleyici haline getireceğiz.</p>
<p>Örnek 13-20, <code>Counter</code> yapısının tanımını ve bu yapının örneklerini oluşturmak amacıyla ilişkilendirilmiş <code>new()</code> işlevini göstermektedir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

fn main() {}

</code></pre></pre>
<p><span class="caption">Örnek 13-20: <code>Counter</code> yapısı ve <code>count</code> alanı başlangıç değeri 0 olan yapı örnekleri başlatan <code>new</code> işlevini tanımlamak</span></p>
<p><code>Counter</code> yapısının <code>count</code> adlı bir alanı vardır. Bu alan, 1’den 5’e kadar olan yineleme sürecinde nerede olduğumuzu takip edecek <code>u32</code> türünden bir değer tuttuğundan ve <code>count</code> uygulamasının değerini yöneteceğinden özeldir. <code>new</code> işlevi ise her yeni örnek başlatıldığında, başlatılan bu örnekleri <code>count</code> alanı sayesinde daima 0 değeriyle ilklendirmeye çalışır.</p>
<p>Daha sonra, Örnek 13-21’de gösterildiği gibi, bu yineleyici kullanıldığında üstleneceği görevleri bildiren <code>next</code> metodunun gövdesini tanımlayarak <code>Counter</code> türüne <code>Iterator</code> özelliğini uygulayacağız:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {}

</code></pre></pre>
<p><span class="caption">Örnek 13-21: <code>Counter</code> yapısına <code>Iterator</code> özelliğini uygulamak</span></p>
<p>Yineleyicimiz için ilişkili öğe türünü <code>u32</code> olarak belirleyip <code>type Item = u32;</code> şeklinde ayarladığımızdan yineleyiciden <code>u32</code> türünde değerler döndürülecektir. Bu noktada <em>İlişkili Türler</em> konusunu Bölüm 19’da ele alacağımızı hatırlatarak konuya devam ediyoruz.</p>
<p>Yineleyicimizin mevcut duruma 1 eklemesini istediğimizden, 1’i döndürebilmesi için <code>count</code> u 0 olarak başlattık. <code>count</code> değeri 5’ten küçük olduğu sürece <code>next</code> metodu <code>count</code> değerini artırarak <code>Some</code> içine sarılmış geçerli değeri döndürecek, <code>count</code> değeri 5 olduğundaysa, yineleyicimiz <code>count</code> değerini artırmayı sona erdirerek <code>None</code> döndürmeye başlayacaktır.</p>
<a class="header" href="#counter-yineleyicisinin-next-metodunu-kullanmak" id="counter-yineleyicisinin-next-metodunu-kullanmak"><h4><code>Counter</code> Yineleyicisinin <code>next</code> Metodunu Kullanmak</h4></a>
<p><code>Iterator</code> özelliğini uyguladığımıza göre artık elimizde bir yineleyicimiz var demektir. Tıpkı Örnek 13-15’te yaptığımız bir <em>vektörden oluşturulan yineleyici</em>de olduğu gibi, aşağıda yer alan Örnek 13-22 de, <code>Counter</code> yapısının yineleme işlevini <code>next</code> metodunu doğrudan çağırarak kullanabileceğimizi gösteren bir test bölümü içerir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
}

fn main() {}

</code></pre></pre>
<p><span class="caption">Örnek 13-22: <code>next</code> metodu uygulamasının işlevselliğini test etmek</span></p>
<p>Bu test, <code>counter</code> değişkeninde yeni bir <code>Counter</code> örneği oluşturur. Ardından <code>next</code> metodunu defalarca çağırıp bu yineleyicinin sahip olmasını istediğimiz davranışı uyguladığımızı doğrulayam 1’den 5’e kadar olan değerleri döndürür.</p>
<a class="header" href="#diğer-iterator-Özellik-metodlarını-kullanmak" id="diğer-iterator-Özellik-metodlarını-kullanmak"><h4>Diğer <code>Iterator</code> Özellik Metodlarını Kullanmak</h4></a>
<p>Artık <code>next</code> metodunu tanımlayarak <code>Iterator</code> özelliğini uyguladığımıza ve hepsinin <code>next</code> metodunun işlevselliğini kullandıklarını bildiğimize göre, bundan böyle standart kitaplıkta tanımlanan tüm <code>Iterator</code> özellik metodlarının varsayılan uygulamalarını kullanabiliriz.</p>
<p>Örnek 13-23’teki testte de gösterildiği gibi, bir <code>Counter</code> örneği tarafından üretilen değerleri almak istediğimizi, bunları ilk değeri atladıktan sonra başka bir <code>Counter</code> örneği tarafından üretilen değerlerle eşleştirdiğimizi, her çifti birbiriyle çarptığımızı ve elde edilen değerlerin sadece 3’e bölünebilenlerini alarak birbiriyle topladığımız bir örneği düşünün:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }

    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
}

fn main() {}

</code></pre></pre>
<p><span class="caption">Örnek 13-23: <code>Counter</code> yineleyicisinde farklı <code>Iterator</code> özellik metodlarını kullanmak</span></p>
<p><code>zip</code> metodu, girdi yineleyicilerinden herhangi birisinin <code>None</code> döndürmesi halinde <code>None</code> varyantını döndüreceğinden, <code>zip</code> ifadesinin yalnızca dört çift oluşturabildiğini ve teorik olarak beşinci çift <code>(5, None)</code> olacağından, hiçbir zaman üretilmeyeceğini aklınızdan çıkarmayın.</p>
<p>Standart kitaplık <code>next</code> metodunu çağıran diğer yöntemler için varsayılan uygulamaları sağladığından, <code>next</code> metodunun nasıl çalıştığını belirledikten sonra metod çağrılarının tamamını kullanmamız mümkündür.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch13-01-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch13-01-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-123456-7', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
